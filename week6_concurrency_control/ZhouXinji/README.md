本周终于看完了CMU的所有视频，做最后一个并发控制的lab。由于涉及到并发，在开始本实验之前，需要对C++中并发相关知识做一些了解。

![vNguMF.png](https://s1.ax1x.com/2022/08/13/vNguMF.png)
> 详细的记录见个人博客

# std::mutex

互斥量是一个可以处于两态之一的变量:解锁和加锁。这样，只需要一个二进制位表示它，不过实际上，常常使用一个整型量，0表示解锁，而其他所有的值则表示加锁。互斥量使用两个过程。当一个线程(或进程)需要访问临界区时，它调用mutex_lock。如果该互斥量当前是解锁的(即临界区可用)，此调用成功，调用线程可以自由进入该临界区。

# std::lock_guard

为了防止我们在使用mutex的过程中意外忘记unlock()，引入了\**\*\*std::lock_guard\*\**\*的类模板，有了该类模板，我们就无需自己去控制对互斥量的加锁与解锁

# std::unique_lock

这里给出另一种模板类std::unique_lock，该模板类的特点相较于std::lock_guard而言，更加的灵活，弹性更高，同时也更加的消耗资源。

# std::condition_variable

这个东西主要用来做线程之间的同步。

